<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
			<meta name="description" content="Exploring WGSL compute shaders to implement ECS state management concepts">
		
		<link rel="stylesheet" href="https://hugodaniel.com/css/base.css">
		<link rel="stylesheet" href="https://hugodaniel.com/css/html-system.css">
		<link rel="stylesheet" href="https://hugodaniel.com/css/dark-mode.css">
		<link rel="stylesheet" href="https://hugodaniel.com/css/desktop.css">
		<link rel="stylesheet" href="https://hugodaniel.com/css/submit-form.css">
		
			<link rel="alternate" type="application/atom+xml" title="Atom Feed" href="https://hugodaniel.com/atom.xml">
		
		
		
		<meta name="twitter:card" content="summary">
		<meta name="twitter:site" content="@mr_hugo">
		<meta name="twitter:creator" content="@mr_hugo">
		
			<title>Shader Language ECS, Part 1 - Idea</title>
			<meta name="twitter:title" content="Shader Language ECS, Part 1 - Idea">
			<meta property="og:title" content="Shader Language ECS, Part 1 - Idea">
			<meta property="og:type" content="article" >
		
		
			<meta name="twitter:description" content="Exploring WGSL compute shaders to implement ECS state management concepts">
			<meta property="og:description" content="Exploring WGSL compute shaders to implement ECS state management concepts">
		
		
			<meta property="og:article:published_time" content="2024-09-01">
		
		<meta property="og:url" content="https:&#x2F;&#x2F;hugodaniel.com&#x2F;posts&#x2F;ecs-wgsl&#x2F;">
		
			<meta property="og:image" content="https://hugodaniel.com/images/ecs_socials.png" >
			<meta name="twitter:image" content="https://hugodaniel.com/images/ecs_socials.png" >
		
		
		
		<!-- Matomo -->
		<script type="text/javascript">
			var _paq = window._paq = window._paq || [];
			/* tracker methods like "setCustomDimension" should be called before "trackPageView" */
			_paq.push(['trackPageView']);
			_paq.push(['enableLinkTracking']);
			(function() {
				var u="//vistas.hugodaniel.pt/";
				_paq.push(['setTrackerUrl', u+'matomo.php']);
				_paq.push(['setSiteId', '2']);
				var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
				g.type='text/javascript'; g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
			})();
		</script>
		<noscript><p><img src="//vistas.hugodaniel.pt/matomo.php?idsite=2&amp;rec=1" style="border:0;" alt="" /></p></noscript>
		<!-- End Matomo Code -->
	</head>
	<body>
		
<main role="main">


	<article class="center-images with-lists">

		<header>
			<h1> Shader Language ECS, Part 1 - Idea </h1>
			<p> Exploring WGSL compute shaders to implement ECS state management concepts </p>
			<nav>
				<time datetime="2024-09-01"> 1-Sep-2024</time>
				<span>
					<a id="back" href="/">About me</a>
					<a href="/posts">All posts</a>
					<a href="/atom.xml">Feed</a>
				</span>
			</nav>
		</header>
		<p>In this post I'm going to try to outline a naive way to do an Entity Component System (ECS) in the shader language WGSL (the WebGPU shader language ).</p>
<p>This is just an idea outline, I currently have no implementation for this, and I strongly doubt about it being a good idea that can produce useful results.</p>
<h3 id="why-would-someone-need-this">Why would someone need this?</h3>
<p>I don't know how to answer this.</p>
<p><img src="/images/ecs_socials.png" alt="&quot;A cat with two wheels on his eyes&quot;" /></p>
<p>This exploration is driven by curiosity about the limits of compute shaders and the potential of WebGPU to reshape how we approach programming. Could we leverage the GPU's parallel processing power for more than just visuals? Is it feasable to bring traditional game state management techniques to the GPU?</p>
<p>There are a lot of tradeoffs being taken which I'll try to address at the end.</p>
<p>I guess that increased portability is eventually a motivation, like at the end of this road if things go well, but not the goal.</p>
<h3 id="ecs-entity-component-system">ECS - Entity Component System</h3>
<p>This is a simple idea that reeks detachment and embraces sparse relationships. The <a href="https://en.wikipedia.org/wiki/Entity_component_system">wikipedia page</a> explains it much better than I can, and <a href="https://www.youtube.com/results?search_query=entity+component+system+explained">there are a lot of youtube videos</a> done by people who are good at explaining things that provide comprehensive angles into this subject.</p>
<p>Regardless, let me take a shot at how I perceive ECS and why I find it cool.</p>
<p>In an Entity Component System (ECS), Entities, Components and Systems are things that you as a programmer define, but in a way that by default they are unrelated to each other.</p>
<p>It's like having all entities to be stored in their own pool (for instance, in regular arrays), the same for components and systems. Three arrays, one for each of these concepts. Or maybe just one with all of them in it, or any other kind of partition that would prevent them to be related in a way that would imply they have know about the others.</p>
<p>Then we develops can ensure that these three concepts get related through indexes/keys into these arrays/pools. Like:</p>
<p><em>"Entity 1 has components 3, 99 and 44, and the movement system needs all entities with component 5 regardless of whatever other components these entities might have".</em></p>
<p><img src="/images/ecs_carro.png" alt="A car and a cat driving it, a list of wheels and a list of positions, cat and car share some of these attributes" title="A cat and car go somewhere, they share the same position, but not the same wheels" /></p>
<p>So, ideally Entities and Components and Systems don't know much about each other:</p>
<ul>
<li>Entities can represent something that exists on the screen.</li>
<li>Components can represent attributes, like position, or color, or any property or stuff that you find useful to have in your app/game.</li>
<li>Systems define how the logic of stuff that happens, like movement, interactions, or anything that can happen.</li>
</ul>
<h3 id="i-didn-t-understand-a-thing">I didn't understand a thing</h3>
<p>Yeah, I really suck at explaining things. ECS is a way to organize the app/game state with the core idea of decoupling data (components) from behavior (systems) and using entities as identifiers.</p>
<p>Essentially you define a bunch of attributes and then a bunch of functions that work and update these attributes.</p>
<p>Each set of attributes gets an id (a number or an uuid or whatever it can be used to identify a set of attributes uniquely).</p>
<p>These three elements are called Entities (which are pointers to) Components (attributes, that get modified by) Systems (functions that get a set of components and update them).</p>
<p>In a way ECS tries to give us some flexibility by enabling systems to work on entities based on the components they have, rather than their predefined inherent type or structure or class etc.</p>
<p>Nevermind, it is not that important I guess.</p>
<h3 id="i-need-my-gpu-for-graphics-not-for-this-stuff">I need my GPU for graphics, not for this stuff</h3>
<p>Despite ECS being a very niche solution with short advantages to app and game state representation, for the purpose of bringing it to the GPU, I'm going to make it even simpler and reduce even more its advantages by removing the ability to update the relationships in runtime.</p>
<p>In WGSL you send a shader code string to the graphics api (WebGPU) which then compiles it into the GPU processor code that gets run with whatever settings you have set.</p>
<p>My idea is to exploit this shader code string creation, and use JS/TS to create a massive string with const arrays and lookups already baked in.</p>
<p>These arrays and lookups would represent the entities and components relationships that were set through JS/TS. It's like using JS/TS as a precompilation language with its Maps and Sets to perform the queries and dump the results in a WGSL string.</p>
<h3 id="attractiveness-is-sweet">Attractiveness is sweet</h3>
<p>WebGPU and WGSL are attractive because they have compute shaders, which are simpler versions of shaders that are focused in computing whatever you want.</p>
<p>Not only that, but unlike WebGL/GLSL, the new WGSL also brings support for pointers and compile time const arrays.</p>
<p>In WebGPU we can create our own pipeline, and dispatch a given entrypoint function of the shader with very specific parallel execution scenarios. I find this a cool thing and wanted to explore it a bit and see how it can be used to implement an ECS.</p>
<h3 id="compute-shaders-dispatches">Compute shaders dispatches</h3>
<p>The rough outline of the simplified ECS for WGSL is this:</p>
<ul>
<li>Components are defined as WGSL structs/types.</li>
<li>JS/TS is used to create the relationships between entities and components</li>
<li>Systems are defined as WGSL functions that read/update components</li>
<li>Systems function arguments define the components query they use</li>
<li>JS/TS parses this system function and performs the queries.</li>
<li>The final WGSL string dispatches each system function once for each query result</li>
</ul>
<h3 id="the-code-outline">The code outline</h3>
<p>My objective is that in the end I can do something like this in JS/TS and have a final WGSL shader string created:</p>
<pre data-lang="typescript" style="background-color:#151515;color:#e8e8d3;" class="language-typescript "><code class="language-typescript" data-lang="typescript"><span style="color:#8fbfdc;">const </span><span style="color:#ffb964;">world </span><span>= </span><span style="color:#fad07a;">createWorld</span><span>();
</span><span style="color:#888888;">// Create an entity
</span><span style="color:#8fbfdc;">const </span><span style="color:#ffb964;">PLAYER </span><span>= </span><span style="color:#ffb964;">world</span><span>.</span><span style="color:#fad07a;">createEntity</span><span>();
</span><span style="color:#888888;">// Create a position component type (A simple 2d vector)
</span><span style="color:#888888;">// and its initialization function
</span><span style="color:#8fbfdc;">const </span><span style="color:#ffb964;">POSITION </span><span>= </span><span style="color:#ffb964;">world</span><span>.</span><span style="color:#fad07a;">createComponent</span><span>(</span><span style="color:#99ad6a;">`
</span><span style="color:#99ad6a;">alias Position = vec2&lt;f32&gt;;
</span><span style="color:#99ad6a;">
</span><span style="color:#99ad6a;">fn init_position(
</span><span style="color:#99ad6a;">  position: ptr&lt;storage, Position, read_write&gt;,
</span><span style="color:#99ad6a;">  i: u32,
</span><span style="color:#99ad6a;">  total_number_of_components: u32
</span><span style="color:#99ad6a;">) {
</span><span style="color:#99ad6a;">    let space = 2.0 / total_number_of_components;
</span><span style="color:#99ad6a;">    let left = -0.5;
</span><span style="color:#99ad6a;">
</span><span style="color:#99ad6a;">    (*position).x = left + float(i) * space;
</span><span style="color:#99ad6a;">}
</span><span style="color:#99ad6a;">
</span><span style="color:#99ad6a;">`</span><span>);
</span><span>
</span><span style="color:#888888;">// Create a distance movement type (here using a struct just because yes)
</span><span style="color:#888888;">// No initialization
</span><span style="color:#8fbfdc;">const </span><span style="color:#ffb964;">MOVEABLE </span><span>= </span><span style="color:#ffb964;">world</span><span>.</span><span style="color:#fad07a;">createComponent</span><span>(</span><span style="color:#99ad6a;">`
</span><span style="color:#99ad6a;">struct Moveable {
</span><span style="color:#99ad6a;">  delta: vec2f,
</span><span style="color:#99ad6a;">};
</span><span style="color:#99ad6a;">`</span><span>);
</span><span>
</span><span style="color:#888888;">// Relate these two components to the player
</span><span style="color:#ffb964;">world</span><span>.</span><span style="color:#fad07a;">addComponentToEntity</span><span>(</span><span style="color:#ffb964;">PLAYER</span><span>, </span><span style="color:#ffb964;">POSITION</span><span>);
</span><span style="color:#ffb964;">world</span><span>.</span><span style="color:#fad07a;">addComponentToEntity</span><span>(</span><span style="color:#ffb964;">PLAYER</span><span>, </span><span style="color:#ffb964;">MOVEABLE</span><span>);
</span><span>
</span><span style="color:#888888;">// A movement system, defined using WGSL function
</span><span style="color:#888888;">// This function will be called for all entities that
</span><span style="color:#888888;">// have the Moveable and the Position components:
</span><span style="color:#ffb964;">world</span><span>.</span><span style="color:#fad07a;">createSystem</span><span>(</span><span style="color:#99ad6a;">`
</span><span style="color:#99ad6a;">fn movement_system(
</span><span style="color:#99ad6a;">    moveable: ptr&lt;storage, Moveable, read_write&gt;,
</span><span style="color:#99ad6a;">    position: ptr&lt;storage, Position, read_write&gt;) {
</span><span style="color:#99ad6a;">    (*position).at += (*moveable).delta;
</span><span style="color:#99ad6a;">}
</span><span style="color:#99ad6a;">`</span><span>);
</span><span>
</span><span style="color:#888888;">// An input update system, same thing with a WGSL function
</span><span style="color:#888888;">// that is called once for all entities that have the Moveable
</span><span style="color:#888888;">// component.
</span><span style="color:#ffb964;">world</span><span>.</span><span style="color:#fad07a;">createSystem</span><span>(</span><span style="color:#99ad6a;">`
</span><span style="color:#99ad6a;">fn keyboard_system(moveable: ptr&lt;storage, Moveable, read_write&gt;) {
</span><span style="color:#99ad6a;">    const amount: f32 = 0.01;
</span><span style="color:#99ad6a;">
</span><span style="color:#99ad6a;">    // Up:
</span><span style="color:#99ad6a;">    if (keyDown(38)) {
</span><span style="color:#99ad6a;">        (*moveable).delta.y = amount;
</span><span style="color:#99ad6a;">        (*moveable).delta.x = 0.0;
</span><span style="color:#99ad6a;">    } else
</span><span style="color:#99ad6a;">    // Down:
</span><span style="color:#99ad6a;">    if (keyDown(40)) {
</span><span style="color:#99ad6a;">        (*moveable).delta.y = -amount;
</span><span style="color:#99ad6a;">        (*moveable).delta.x = 0.0;
</span><span style="color:#99ad6a;">    } else
</span><span style="color:#99ad6a;">    // Left:
</span><span style="color:#99ad6a;">    if (keyDown(37)) {
</span><span style="color:#99ad6a;">        (*moveable).delta.x = -amount;
</span><span style="color:#99ad6a;">        (*moveable).delta.y = 0.0;
</span><span style="color:#99ad6a;">    } else
</span><span style="color:#99ad6a;">    // Right:
</span><span style="color:#99ad6a;">    if (keyDown(39)) {
</span><span style="color:#99ad6a;">        (*moveable).delta.x = amount;
</span><span style="color:#99ad6a;">        (*moveable).delta.y = 0.0;
</span><span style="color:#99ad6a;">    }
</span><span style="color:#99ad6a;">}
</span><span style="color:#99ad6a;">`</span><span>);
</span><span>
</span><span style="color:#888888;">// The shader string to send to the GPU
</span><span style="color:#8fbfdc;">const </span><span style="color:#ffb964;">shader </span><span>= </span><span style="color:#ffb964;">world</span><span>.</span><span style="color:#fad07a;">generateWGSL</span><span>();
</span></code></pre>
<p>Thats the idea for the API, maybe a few other small utilitarian functions as needed here and there.</p>
<h3 id="the-output-outline">The output outline</h3>
<video controls muted loop preload width="100%">
  <source src="/videos/wgsl_ecs_circles.webm" type="video/webm">
  <source src="/videos/wgsl_ecs_circles.mp4" type="video/mp4">
</video>
<p>Did a quick rough sketch of this in compute.toys, their single string allows to specify multiple dispatch entry points.</p>
<p>In the end I intend to have a WGSL string somewhat like this: <a href="https://compute.toys/view/1377">https://compute.toys/view/1377</a>.</p>
<p>Outlining it:</p>
<ul>
<li>
<p>A WGSL string that does one dispatch per system function. With components hardcoded into it in static const arrays.</p>
</li>
<li>
<p>Initialization is done inline as much as possible.</p>
</li>
<li>
<p>No dynamic updates. A dynamic update of a relationship would imply a string rewrite and WGSL shader recompilation.</p>
</li>
</ul>
<p>I think that this can be ok for scenarios where the entity-component relationships are relatively static or the performance overhead of dynamic updates is acceptable.</p>
<h3 id="pros-and-cons">Pros and Cons</h3>
<p>There might be some advantages that I cannot exactly measure at this idea stage but only guess:</p>
<ul>
<li>Is there some usefulness in having the state management done in the same language as the graphics?
<ul>
<li>Could this lead to better low hanging fruit optimization opportunities and reduced communication overhead between CPU and GPU?</li>
</ul>
</li>
<li>Will it be massively slow to re-compile a big shader with everything in it? (i would love to benchmark WGSL compilation times at some point)
<ul>
<li>I think that this could be a major bottleneck, especially for dynamic scenes or frequent updates.</li>
</ul>
</li>
<li>Can we easily produce mind-bending stuff when the state is tightly coupled with the graphics?
<ul>
<li>There might be some potential here for unique visual effects and gameplay mechanics that make use of the GPU capabilities.</li>
</ul>
</li>
<li>Debugging will be super hard (if not impossible), but I plan and hope to make some developments here in the near future.</li>
<li>Performance? I doubt there will be any performance gains at all immediately and I'm not sure I can produce good enough data points to conclude anything on this.</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>I don't have any nice lib or API documentation to show at this point, this is only a sketch.</p>
<p>In my next post I'll try to bring this whole thing together and show something a bit more complex that can at least provide some hints about the massive tradeoffs of something like this.</p>
<p>I'm super curious to see how badly this will tank, or if I can find some way to make this useful or even slightly justifiable.</p>
<p>I am excited about this and there are a lot of unknowns at this point so I wonder where all of this might go.</p>

      <!--
    <p>Did you enjoy what you read? Was it inspiring or compelling in any way?
    <br> I can send you one e-mail per month with a quick recap of the posts I have written.
    <br><a href="#subscribe" class="subscribe">You can subscribe here.</a></p>
-->
	</article>
	<hr>
	<footer>
		<nav>
			<a target="_blank" href="https://github.com/HugoDaniel" rel="external">GitHub</a>
			<a target="_blank" href="https://bsky.app/profile/hugodan.bsky.social" rel="external">bsky</a>
			<a target="_blank" href="https://www.linkedin.com/in/mrhugogomes/" rel="external">LinkedIN</a>
			<a href="mailto:hello@hugodaniel.com">e-mail</a>
		</nav>
	</footer>
</main>
<script type="module">
  const hideForm = () => {
    document.body.removeChild(
      document.querySelector(".formContainer")
    );
    document.querySelector("main").classList.remove("blur");
  }
  const showForm = () => {
    let formDiv = document.createElement("div");
    formDiv.setAttribute("class", "formContainer")
    formDiv.addEventListener("click", (e) => {
      e.preventDefault();
      hideForm();
    })
    formDiv.innerHTML = `
  <section id="imediatos">
    <form class="objetos" method="POST" action="https://hugodaniel.pt/subs.php">
      <h3>You will receive <br>the list of articles I have written<br>in one e-mail per month</h3>
    <div class="Input">
      <input id="inputName" type=text placeholder="Hugo" name="Name">
      <label>Name</label>
    </div>
    <div class="Input">
      <input type=email name="Email">
      <label>E-Mail</label>
    </div>
    <div class="Submit">
      <button id="formSubmit" type="submit">Subscribe</button>
    </div>
    </form>
  </section>
    `
    document.body.appendChild(formDiv);
    document.querySelector("main").classList.add("blur");
    requestAnimationFrame(() => { 
      document.getElementById("imediatos")
              .addEventListener("click", (e) => e.stopPropagation())
      document.getElementById("formSubmit")
              .addEventListener("click", (e) => {
        requestAnimationFrame(() => document.getElementById("formSubmit").setAttribute("disabled", "")
        );
      })
      document.getElementById("inputName").focus(); 
    });
  }
  document.querySelector(".subscribe").addEventListener("click",
  (e) => {
    e.preventDefault();
    showForm();
  })
</script>

	</body>
</html>
