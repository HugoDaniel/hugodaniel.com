<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1">
		
			<meta name="description" content="A few hints to get started using nvi, a lean and clean terminal based editor">
		
		<link rel="stylesheet" href="https:&#x2F;&#x2F;hugodaniel.com&#x2F;css&#x2F;base.css">
		
			<link rel="alternate" type="application/rss+xml" title="RSS" href="https:&#x2F;&#x2F;hugodaniel.com&#x2F;rss.xml">
		
		
		
		<meta name="twitter:card" content="summary">
		<meta name="twitter:site" content="@mr_hugo">
		<meta name="twitter:creator" content="@mr_hugo">
		
			<title>vi is not vim</title>
			<meta name="twitter:title" content="vi is not vim">
			<meta property="og:title" content="vi is not vim">
			<meta property="og:type" content="article" >
		
		
			<meta name="twitter:description" content="A few hints to get started using nvi, a lean and clean terminal based editor">
			<meta property="og:description" content="A few hints to get started using nvi, a lean and clean terminal based editor">
		
		
			<meta property="og:article:published_time" content="2017-08-12">
		
		<meta property="og:url" content="https:&#x2F;&#x2F;hugodaniel.com&#x2F;posts&#x2F;vi-is-not-vim&#x2F;">
		
		<!-- Matomo -->
		<script type="text/javascript">
			var _paq = window._paq = window._paq || [];
			/* tracker methods like "setCustomDimension" should be called before "trackPageView" */
			_paq.push(['trackPageView']);
			_paq.push(['enableLinkTracking']);
			(function() {
				var u="//vistas.hugodaniel.pt/";
				_paq.push(['setTrackerUrl', u+'matomo.php']);
				_paq.push(['setSiteId', '2']);
				var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];
				g.type='text/javascript'; g.async=true; g.src=u+'matomo.js'; s.parentNode.insertBefore(g,s);
			})();
		</script>
		<noscript><p><img src="//vistas.hugodaniel.pt/matomo.php?idsite=2&amp;rec=1" style="border:0;" alt="" /></p></noscript>
		<!-- End Matomo Code -->
	</head>
	<body>
		
<main role="main"> 
	<article>
		<header>
			<h1> vi is not vim </h1>
			<p> A few hints to get started using nvi, a lean and clean terminal based editor </p>
			<nav>
				<time datetime="2017-08-12">12-Aug-2017</time>
				<span>
					<a id="back" href="/">About me</a>
					<a target="_blank" href="http://www.twitter.com/mr_hugo" rel="external nofollow">@mr_hugo</a>
					<a href="/posts">All posts</a>
				</span>
			</nav>
		</header>
		<p>When dinossaurs ruled the earth there was a young kid that had just installed Red Hat Linux 5 on his computer.<br/>
Fascinated with the &quot;OS for the elite&quot; he was about to experience a devouring frustration.
The kind that gives rise to dark divinities that come to haunt you in your sleep for years to come:</p>
<p>Trying to exit vim.</p>
<p>After a few unsuccessful atempts the computer <em>power switch</em> was the only option left. Like that the dream of a promising carreer in elite-land was shattered for that young boy.</p>
<p>That young boy was me.</p>
<h2 id="high-tech-editor-low-tech-coder">High tech editor, low tech coder</h2>
<p>My stubbornness always took the best part of my reason and vim was my editor for years to come. Since rough starts are the perfect driver for a good love story I then ditched it to take a stroll in netbeans land. <br/>After a while a pardon was due and got back to it again. Then I ditched it again for Visual Studio. <br/>Got back to it again. And so on.</p>
<p>Code editors today try to do everything and a pair of boots. Even vim, known for its minimalist looks, is very prone to config-pr0n worthy of the most wild and nasty fantasies.</p>
<h2 id="i-ll-show-you-mine-if-you-show-me-yours">I'll show you mine if you show me yours</h2>
<p>At one point I got myself in the middle of a config discussion between developers. They were arguing about good .vimrc config options and plugins for vim.</p>
<p>I decided to participate and show my ~60 lines .vimrc file. They laughed. It was so small. Almost useless.</p>
<p>That got me thinking:</p>
<p><strong>What do i <em>really</em> need in a code editor ?</strong></p>
<p>After giving a hard thought on my usage/preferences and some possible optimizations I took a look into the market of code editors and decided to <strong>upgrade from vim to vi</strong> (by vi I mean <a href="http://repo.or.cz/nvi.git">nvi 1.81.6, still maintained and developed here</a> ).</p>
<p>The rest of this blog post is about some nvi parts (vi, not vim), in particular some parts that are percieved as limitations. I will run through them and try to provide arguments that favor them and reasons to use them. Have your salt and pepper at hand before reading further.</p>
<h2 id="minimal-config-file-exrc">Minimal config file (.exrc)</h2>
<p>The nvi config file is named .exrc, here is my current setup:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">set showmode
set showmatch
set ruler
set shiftwidth=2
set tabstop=2
set verbose
set leftright
set cedit=\
set filec=\
</span></code></pre>
<p>9 lines only. No maintenance. No BS.</p>
<p>These options are mostly similar to those in .vimrc, a special note for cedit and filec, these have a =\&lt;TAB&gt; (the &lt;TAB&gt; is the actual tab character there after the \).
The <strong>cedit</strong> property sets the character to trigger command expansion in the vi command colon mode. The <strong>filec</strong> sets the the character for file name expansion (auto-complete) when opening a new file inside vi (e.g. with :e).</p>
<p>All of these are well documented in the man page.</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">$ man nvi
</span></code></pre><h2 id="no-unicode-support">No unicode support</h2>
<p>There are some vi implementations that support multibyte characters like <a href="https://github.com/lichray/nvi2">nvi2</a>. But for this blog post I am assuming your vi is plain <a href="https://sites.google.com/a/bostic.com/keithbostic/vi/">nvi</a>.</p>
<p>No multibyte, wide-char, wtf-8, extended codepoints. Although those are very important to learn and master I do prefer to keep code in plain strict single-byte ASCII (UTF-8 supersedes it).</p>
<p><strong>Why ?</strong></p>
<p>It keeps the language coherent with the programming reserved words (more than logic constructs, <em>while</em>, <em>for</em>, <em>if</em>, are english words).</p>
<p>It makes it perfectly visible when an accidental wide-char is inserted (particularly helpful if you are using a keyboard layout that does not use the US key-mapping). This is good to make sure your code is available to read on every system, regardless of locale (it even works if someone opens the code you wrote in an editor that is set to default to UTF-8 encoding).</p>
<p>Another good thing is that it works with a wider variety of fonts. Some monospace terminal fonts can't correctly display all UTF-8 characters.</p>
<p><strong>But I sometimes need to write documents with strange characters</strong></p>
<p>That is one of the scenarios where I would use another text editor. nvi is strictly a code/config editor.</p>
<h2 id="no-syntax-highlighting">No syntax highlighting</h2>
<p>This is another personal preference. It has been a long time since I had to worry about syntax when producing code. If you still struggle with syntax then please use syntax highlighting, it will help those special words stand out.
Otherwise why not give it a try without syntax highlighting for a while (a few weeks to be slightly above the habituation threshold) and measure how you perform ?</p>
<p>It does help to keep your functions small and easy to read.</p>
<p>Comments are shown with their true weight and your commented code is promoted to the same importance as your production code.</p>
<p>Your focus will be in semantics and it is easier to get into it without the syntax aggressively jumping at your face.</p>
<h2 id="fast-undo">Fast undo</h2>
<p>Like in vim the undo in vi is very convenient but has a slightly different way of operating. Instead of pressing <em>u</em> multiple times to go through the various undo levels and then ctrl-r to redo, in vi you do it by pressing <em>u</em> once to undo and the '<strong>.</strong>' to go through the various undo levels.</p>
<p>To redo you press <em>u</em> twice (undo the undo) and then '<strong>.</strong>' to go through the multiple redo levels.</p>
<p>I think this is slightly more coherent and it also makes use of the '<strong>.</strong>' (repeat action) operator in an arguably more logical way.</p>
<p>Like in vim, you can use the <em>U</em> command to restore a line to the state it was before the cursor was placed on top of it (undoing all the chances since that time).</p>
<h2 id="no-visual-mode">No visual mode</h2>
<p>There is no visual mode in vi (visual mode as in pressing the <em>v</em> command and using your movement keys to select an area of text).</p>
<p>At first this might seem like a big handicap, but vi shares a few commands with vim that once mastered can make you more productive than using the visual mode.</p>
<p><strong>Marks <em>m&lt;insert letter here&gt;</em></strong></p>
<p>You can setup marks in text, if you type <em>mx</em> it will define the mark x at the current cursor position. Typically these are used to move quickly through the file and go to certain marked positions. For that the ' command is used followed by the mark character name (moves to the line) or with the ` command (moves to the exact cursor position of the mark). To move to mark x do 'x (assuming you did <em>mx</em> in some place before).</p>
<p>Marks can also be used with other common commands like yank, delete, etc..., so instead of using the visual mode you can yank or delete to a a mark set at some position.<br/>
To do that use the <em>t</em> or <em>f</em> commands, like ytx (I read it as: <em>y</em>ank <em>t</em>o <em>x</em>), it will yank all lines up to (but not including) the line at mark x. To include it use the <em>f</em> as in yfx.</p>
<h2 id="no-tabs">No tabs</h2>
<p>Tabs was a feature that I used a lot in vim, unfortunately they only work with vim, so if you want to run a shell command or have a terminal to read compiler output you will need to use them with some other kind of tab system.</p>
<p>On my journey to the limits of usefulness I found myself using vim tabs together with tmux tabs and terminal (osx) tabs.</p>
<p>After those crazy days (months ?) I finally decided to ditch all tabs and stick to a single tool for that purpose, one that is versatile enough to cover my use cases for tabs.</p>
<p><strong>Do one thing and do it well</strong></p>
<p><a href="https://github.com/tmux/tmux/wiki">Tmux</a> is my current tool of choice, nowadays I don't use terminal tabs or text editor tabs. I leave that work for tmux, an amazing productivity tool that allows me to work fullscreen in zen mode with the code.</p>
<p><strong>Panes in vi</strong></p>
<p>Like in vim you can split your window with panes, these are useful to use another section of code as a quick reference or to do some quick yank/past in vi between files/sections.</p>
<p>The pane system in vi works slightly different from vim. To vertically split the window you can also use the :vs, but to horizontally split the window :sp won't work. In vi the command to horizontally split a window is the :E, as in Edit (the same as :e but horizontally split).</p>
<p>To switch between panes ctrl-w will immediately move your cursor to the next window pane. Instead of pressing twice like vim you only need to press it once. This is hard to get used to at first but it is also hard to live without once used to it.</p>
<p><img src="/images/nvi_tmux_macos.png" alt="My nvi with tmux on macos" /></p>
<h2 id="no-macros">No macros</h2>
<p>One feature that I consistently used in vim was macros (vim <em>q</em> command). It was easy to create bundles of commands and run them to do your repeated text tasks or grunt work. Very useful when replicating huge data files or setting up a <a href="https://hugodaniel.com/posts/mastering-console-log/">big JSON test file</a>.</p>
<p>In vi you can also use the power of macros through buffers.</p>
<p><strong>Buff it up</strong></p>
<p>Buffers are easy to use, you can prefix your common text manipulation commands (dd, yy, etc...) to a named buffer. To do that start the command with &quot;&lt;buffer name&gt; where &lt;buffer name&gt; is any letter from a-z.</p>
<p>Here are some examples:</p>
<ul>
<li>
<p><strong>To delete 4 lines and place them into buffer a</strong> &quot;a4dd</p>
</li>
<li>
<p><strong>To paste buffer <em>a</em> to the current cursor position</strong> &quot;ap</p>
</li>
<li>
<p><strong>To view all your buffers go to ex mode (:) and do</strong> :di b</p>
</li>
</ul>
<p><strong>Who needs macros when you have buffers</strong></p>
<p>Write a few commands to be executed in your file, place then in a buffer and tell vi that you want to execute the buffer:</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">2)
4dd
G
</span></code></pre>
<p>Line by line:</p>
<ol>
<li>
<p>move two lines down</p>
</li>
<li>
<p>delete 4 lines</p>
</li>
<li>
<p>go to the end of the file</p>
</li>
</ol>
<p>Put these into a buffer named <em>c</em> with <i>&quot;c3yy</i> (yank 3 lines into buffer <em>c</em>), and whenever you want to run it just do <em>@ c</em>. Undo <em>u</em> also works nicely with buffered commands.</p>
<h2 id="upgrading-from-vim-to-vi">Upgrading from vim to vi</h2>
<p>There are some cool benefits in using vi like how fast it is and how it handles huge files without a problem.</p>
<p>nvi also performs well in <a href="https://github.com/jhallen/joes-sandbox/blob/master/editor-perf/readme.md">this benchmark of editors</a></p>
<p>The case for vi is like any other editor: a matter of getting used to it and keep perfecting your skills through it for what it really matters: writting great code.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Use what you are more confortable with. There are tradeoffs in every editor (even the mighty visual studio code does not allow you to work without syntax highlighting on...) and today nvi fits nicely with my way of working and approach.</p>
<p>I hope this post to be used as a initial reference and motivation to those that are looking for a more minimalistic way of doing things. I don't intend it to start flame wars.</p>
<p>You know all of these are just my opinions :)</p>

	</article>
	<hr>
	<footer>
		<nav>
			<a target="_blank" href="https://github.com/HugoDaniel" rel="external nofollow">GitHub</a>
			<a target="_blank" href="https://twitter.com/mr_hugo" rel="external nofollow">Twitter</a>
			<a target="_blank" href="https://www.linkedin.com/in/mrhugogomes/" rel="external nofollow">LinkedIN</a>
			<a href="mailto:hello@hugodaniel.com">e-mail</a>
		</nav>
	</footer>
</main>


	<!--
		<footer>
			<div>
				<p>Latest project</p>
				<a href="https://gridgenerator.com" target="_blank">Grid Generator</a>
			</div>
			<nav>
				<a target="_blank" href="https://twitter.com/mr_hugo">
					<img src="https:&#x2F;&#x2F;hugodaniel.com&#x2F;images&#x2F;twitter.svg" alt="Twitter" />
				</a>
				<a target="_blank" href="https://github.com/HugoDaniel">
					<img src="https:&#x2F;&#x2F;hugodaniel.com&#x2F;images&#x2F;github.svg" alt="GitHub" />
				</a>
				<a target="_blank" href="https://www.linkedin.com/in/mrhugogomes/">
					<img src="https:&#x2F;&#x2F;hugodaniel.com&#x2F;images&#x2F;linkedin.svg" alt="LinkedIn" />
				</a>
			</nav>
			<div>
				<p>Liked what you read ?</p>
				<a href="mailto:mail@hugodaniel.pt">Say hello :)!</a>
			</div>
		</footer>
	-->
		<script>
			console.log({
  "config": {
    "base_url": "https://hugodaniel.com",
    "theme": null,
    "title": null,
    "description": null,
    "default_language": "en",
    "languages": [],
    "translations": {},
    "highlight_code": true,
    "highlight_theme": "base16-ocean-dark",
    "generate_feed": true,
    "feed_limit": null,
    "feed_filename": "atom.xml",
    "hard_link_static": false,
    "taxonomies": [],
    "compile_sass": false,
    "minify_html": false,
    "build_search_index": true,
    "ignored_content": [],
    "extra_syntaxes": [],
    "link_checker": {
      "skip_prefixes": [],
      "skip_anchor_prefixes": []
    },
    "slugify": {
      "paths": "on",
      "taxonomies": "on",
      "anchors": "on"
    },
    "search": {
      "include_title": true,
      "include_content": true,
      "truncate_content_length": null,
      "include_description": false
    },
    "extra": {}
  },
  "current_path": "/posts/vi-is-not-vim/",
  "current_url": "https://hugodaniel.com/posts/vi-is-not-vim/",
  "lang": "en",
  "page": {
    "relative_path": "posts/2017-08-12-vi-is-not-vim.md",
    "content": "<p>When dinossaurs ruled the earth there was a young kid that had just installed Red Hat Linux 5 on his computer.<br/>\nFascinated with the &quot;OS for the elite&quot; he was about to experience a devouring frustration.\nThe kind that gives rise to dark divinities that come to haunt you in your sleep for years to come:</p>\n<p>Trying to exit vim.</p>\n<p>After a few unsuccessful atempts the computer <em>power switch</em> was the only option left. Like that the dream of a promising carreer in elite-land was shattered for that young boy.</p>\n<p>That young boy was me.</p>\n<h2 id=\"high-tech-editor-low-tech-coder\">High tech editor, low tech coder</h2>\n<p>My stubbornness always took the best part of my reason and vim was my editor for years to come. Since rough starts are the perfect driver for a good love story I then ditched it to take a stroll in netbeans land. <br/>After a while a pardon was due and got back to it again. Then I ditched it again for Visual Studio. <br/>Got back to it again. And so on.</p>\n<p>Code editors today try to do everything and a pair of boots. Even vim, known for its minimalist looks, is very prone to config-pr0n worthy of the most wild and nasty fantasies.</p>\n<h2 id=\"i-ll-show-you-mine-if-you-show-me-yours\">I'll show you mine if you show me yours</h2>\n<p>At one point I got myself in the middle of a config discussion between developers. They were arguing about good .vimrc config options and plugins for vim.</p>\n<p>I decided to participate and show my ~60 lines .vimrc file. They laughed. It was so small. Almost useless.</p>\n<p>That got me thinking:</p>\n<p><strong>What do i <em>really</em> need in a code editor ?</strong></p>\n<p>After giving a hard thought on my usage/preferences and some possible optimizations I took a look into the market of code editors and decided to <strong>upgrade from vim to vi</strong> (by vi I mean <a href=\"http://repo.or.cz/nvi.git\">nvi 1.81.6, still maintained and developed here</a> ).</p>\n<p>The rest of this blog post is about some nvi parts (vi, not vim), in particular some parts that are percieved as limitations. I will run through them and try to provide arguments that favor them and reasons to use them. Have your salt and pepper at hand before reading further.</p>\n<h2 id=\"minimal-config-file-exrc\">Minimal config file (.exrc)</h2>\n<p>The nvi config file is named .exrc, here is my current setup:</p>\n<pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\">set showmode\nset showmatch\nset ruler\nset shiftwidth=2\nset tabstop=2\nset verbose\nset leftright\nset cedit=\\\nset filec=\\\n</span></code></pre>\n<p>9 lines only. No maintenance. No BS.</p>\n<p>These options are mostly similar to those in .vimrc, a special note for cedit and filec, these have a =\\&lt;TAB&gt; (the &lt;TAB&gt; is the actual tab character there after the \\).\nThe <strong>cedit</strong> property sets the character to trigger command expansion in the vi command colon mode. The <strong>filec</strong> sets the the character for file name expansion (auto-complete) when opening a new file inside vi (e.g. with :e).</p>\n<p>All of these are well documented in the man page.</p>\n<pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\">$ man nvi\n</span></code></pre><h2 id=\"no-unicode-support\">No unicode support</h2>\n<p>There are some vi implementations that support multibyte characters like <a href=\"https://github.com/lichray/nvi2\">nvi2</a>. But for this blog post I am assuming your vi is plain <a href=\"https://sites.google.com/a/bostic.com/keithbostic/vi/\">nvi</a>.</p>\n<p>No multibyte, wide-char, wtf-8, extended codepoints. Although those are very important to learn and master I do prefer to keep code in plain strict single-byte ASCII (UTF-8 supersedes it).</p>\n<p><strong>Why ?</strong></p>\n<p>It keeps the language coherent with the programming reserved words (more than logic constructs, <em>while</em>, <em>for</em>, <em>if</em>, are english words).</p>\n<p>It makes it perfectly visible when an accidental wide-char is inserted (particularly helpful if you are using a keyboard layout that does not use the US key-mapping). This is good to make sure your code is available to read on every system, regardless of locale (it even works if someone opens the code you wrote in an editor that is set to default to UTF-8 encoding).</p>\n<p>Another good thing is that it works with a wider variety of fonts. Some monospace terminal fonts can't correctly display all UTF-8 characters.</p>\n<p><strong>But I sometimes need to write documents with strange characters</strong></p>\n<p>That is one of the scenarios where I would use another text editor. nvi is strictly a code/config editor.</p>\n<h2 id=\"no-syntax-highlighting\">No syntax highlighting</h2>\n<p>This is another personal preference. It has been a long time since I had to worry about syntax when producing code. If you still struggle with syntax then please use syntax highlighting, it will help those special words stand out.\nOtherwise why not give it a try without syntax highlighting for a while (a few weeks to be slightly above the habituation threshold) and measure how you perform ?</p>\n<p>It does help to keep your functions small and easy to read.</p>\n<p>Comments are shown with their true weight and your commented code is promoted to the same importance as your production code.</p>\n<p>Your focus will be in semantics and it is easier to get into it without the syntax aggressively jumping at your face.</p>\n<h2 id=\"fast-undo\">Fast undo</h2>\n<p>Like in vim the undo in vi is very convenient but has a slightly different way of operating. Instead of pressing <em>u</em> multiple times to go through the various undo levels and then ctrl-r to redo, in vi you do it by pressing <em>u</em> once to undo and the '<strong>.</strong>' to go through the various undo levels.</p>\n<p>To redo you press <em>u</em> twice (undo the undo) and then '<strong>.</strong>' to go through the multiple redo levels.</p>\n<p>I think this is slightly more coherent and it also makes use of the '<strong>.</strong>' (repeat action) operator in an arguably more logical way.</p>\n<p>Like in vim, you can use the <em>U</em> command to restore a line to the state it was before the cursor was placed on top of it (undoing all the chances since that time).</p>\n<h2 id=\"no-visual-mode\">No visual mode</h2>\n<p>There is no visual mode in vi (visual mode as in pressing the <em>v</em> command and using your movement keys to select an area of text).</p>\n<p>At first this might seem like a big handicap, but vi shares a few commands with vim that once mastered can make you more productive than using the visual mode.</p>\n<p><strong>Marks <em>m&lt;insert letter here&gt;</em></strong></p>\n<p>You can setup marks in text, if you type <em>mx</em> it will define the mark x at the current cursor position. Typically these are used to move quickly through the file and go to certain marked positions. For that the ' command is used followed by the mark character name (moves to the line) or with the ` command (moves to the exact cursor position of the mark). To move to mark x do 'x (assuming you did <em>mx</em> in some place before).</p>\n<p>Marks can also be used with other common commands like yank, delete, etc..., so instead of using the visual mode you can yank or delete to a a mark set at some position.<br/>\nTo do that use the <em>t</em> or <em>f</em> commands, like ytx (I read it as: <em>y</em>ank <em>t</em>o <em>x</em>), it will yank all lines up to (but not including) the line at mark x. To include it use the <em>f</em> as in yfx.</p>\n<h2 id=\"no-tabs\">No tabs</h2>\n<p>Tabs was a feature that I used a lot in vim, unfortunately they only work with vim, so if you want to run a shell command or have a terminal to read compiler output you will need to use them with some other kind of tab system.</p>\n<p>On my journey to the limits of usefulness I found myself using vim tabs together with tmux tabs and terminal (osx) tabs.</p>\n<p>After those crazy days (months ?) I finally decided to ditch all tabs and stick to a single tool for that purpose, one that is versatile enough to cover my use cases for tabs.</p>\n<p><strong>Do one thing and do it well</strong></p>\n<p><a href=\"https://github.com/tmux/tmux/wiki\">Tmux</a> is my current tool of choice, nowadays I don't use terminal tabs or text editor tabs. I leave that work for tmux, an amazing productivity tool that allows me to work fullscreen in zen mode with the code.</p>\n<p><strong>Panes in vi</strong></p>\n<p>Like in vim you can split your window with panes, these are useful to use another section of code as a quick reference or to do some quick yank/past in vi between files/sections.</p>\n<p>The pane system in vi works slightly different from vim. To vertically split the window you can also use the :vs, but to horizontally split the window :sp won't work. In vi the command to horizontally split a window is the :E, as in Edit (the same as :e but horizontally split).</p>\n<p>To switch between panes ctrl-w will immediately move your cursor to the next window pane. Instead of pressing twice like vim you only need to press it once. This is hard to get used to at first but it is also hard to live without once used to it.</p>\n<p><img src=\"/images/nvi_tmux_macos.png\" alt=\"My nvi with tmux on macos\" /></p>\n<h2 id=\"no-macros\">No macros</h2>\n<p>One feature that I consistently used in vim was macros (vim <em>q</em> command). It was easy to create bundles of commands and run them to do your repeated text tasks or grunt work. Very useful when replicating huge data files or setting up a <a href=\"https://hugodaniel.com/posts/mastering-console-log/\">big JSON test file</a>.</p>\n<p>In vi you can also use the power of macros through buffers.</p>\n<p><strong>Buff it up</strong></p>\n<p>Buffers are easy to use, you can prefix your common text manipulation commands (dd, yy, etc...) to a named buffer. To do that start the command with &quot;&lt;buffer name&gt; where &lt;buffer name&gt; is any letter from a-z.</p>\n<p>Here are some examples:</p>\n<ul>\n<li>\n<p><strong>To delete 4 lines and place them into buffer a</strong> &quot;a4dd</p>\n</li>\n<li>\n<p><strong>To paste buffer <em>a</em> to the current cursor position</strong> &quot;ap</p>\n</li>\n<li>\n<p><strong>To view all your buffers go to ex mode (:) and do</strong> :di b</p>\n</li>\n</ul>\n<p><strong>Who needs macros when you have buffers</strong></p>\n<p>Write a few commands to be executed in your file, place then in a buffer and tell vi that you want to execute the buffer:</p>\n<pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\">2)\n4dd\nG\n</span></code></pre>\n<p>Line by line:</p>\n<ol>\n<li>\n<p>move two lines down</p>\n</li>\n<li>\n<p>delete 4 lines</p>\n</li>\n<li>\n<p>go to the end of the file</p>\n</li>\n</ol>\n<p>Put these into a buffer named <em>c</em> with <i>&quot;c3yy</i> (yank 3 lines into buffer <em>c</em>), and whenever you want to run it just do <em>@ c</em>. Undo <em>u</em> also works nicely with buffered commands.</p>\n<h2 id=\"upgrading-from-vim-to-vi\">Upgrading from vim to vi</h2>\n<p>There are some cool benefits in using vi like how fast it is and how it handles huge files without a problem.</p>\n<p>nvi also performs well in <a href=\"https://github.com/jhallen/joes-sandbox/blob/master/editor-perf/readme.md\">this benchmark of editors</a></p>\n<p>The case for vi is like any other editor: a matter of getting used to it and keep perfecting your skills through it for what it really matters: writting great code.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>Use what you are more confortable with. There are tradeoffs in every editor (even the mighty visual studio code does not allow you to work without syntax highlighting on...) and today nvi fits nicely with my way of working and approach.</p>\n<p>I hope this post to be used as a initial reference and motivation to those that are looking for a more minimalistic way of doing things. I don't intend it to start flame wars.</p>\n<p>You know all of these are just my opinions :)</p>\n",
    "permalink": "https://hugodaniel.com/posts/vi-is-not-vim/",
    "slug": "vi-is-not-vim",
    "ancestors": [
      "_index.md",
      "posts/_index.md"
    ],
    "title": "vi is not vim",
    "description": "A few hints to get started using nvi, a lean and clean terminal based editor",
    "updated": null,
    "date": "2017-08-12",
    "year": 2017,
    "month": 8,
    "day": 12,
    "taxonomies": {},
    "extra": {
      "place": "Lisboa",
      "author": "Hugo Daniel"
    },
    "path": "/posts/vi-is-not-vim/",
    "components": [
      "posts",
      "vi-is-not-vim"
    ],
    "summary": null,
    "toc": [
      {
        "level": 2,
        "id": "high-tech-editor-low-tech-coder",
        "permalink": "https://hugodaniel.com/posts/vi-is-not-vim/#high-tech-editor-low-tech-coder",
        "title": "High tech editor, low tech coder",
        "children": []
      },
      {
        "level": 2,
        "id": "i-ll-show-you-mine-if-you-show-me-yours",
        "permalink": "https://hugodaniel.com/posts/vi-is-not-vim/#i-ll-show-you-mine-if-you-show-me-yours",
        "title": "I'll show you mine if you show me yours",
        "children": []
      },
      {
        "level": 2,
        "id": "minimal-config-file-exrc",
        "permalink": "https://hugodaniel.com/posts/vi-is-not-vim/#minimal-config-file-exrc",
        "title": "Minimal config file (.exrc)",
        "children": []
      },
      {
        "level": 2,
        "id": "no-unicode-support",
        "permalink": "https://hugodaniel.com/posts/vi-is-not-vim/#no-unicode-support",
        "title": "No unicode support",
        "children": []
      },
      {
        "level": 2,
        "id": "no-syntax-highlighting",
        "permalink": "https://hugodaniel.com/posts/vi-is-not-vim/#no-syntax-highlighting",
        "title": "No syntax highlighting",
        "children": []
      },
      {
        "level": 2,
        "id": "fast-undo",
        "permalink": "https://hugodaniel.com/posts/vi-is-not-vim/#fast-undo",
        "title": "Fast undo",
        "children": []
      },
      {
        "level": 2,
        "id": "no-visual-mode",
        "permalink": "https://hugodaniel.com/posts/vi-is-not-vim/#no-visual-mode",
        "title": "No visual mode",
        "children": []
      },
      {
        "level": 2,
        "id": "no-tabs",
        "permalink": "https://hugodaniel.com/posts/vi-is-not-vim/#no-tabs",
        "title": "No tabs",
        "children": []
      },
      {
        "level": 2,
        "id": "no-macros",
        "permalink": "https://hugodaniel.com/posts/vi-is-not-vim/#no-macros",
        "title": "No macros",
        "children": []
      },
      {
        "level": 2,
        "id": "upgrading-from-vim-to-vi",
        "permalink": "https://hugodaniel.com/posts/vi-is-not-vim/#upgrading-from-vim-to-vi",
        "title": "Upgrading from vim to vi",
        "children": []
      },
      {
        "level": 2,
        "id": "conclusion",
        "permalink": "https://hugodaniel.com/posts/vi-is-not-vim/#conclusion",
        "title": "Conclusion",
        "children": []
      }
    ],
    "word_count": 1896,
    "reading_time": 10,
    "assets": [],
    "draft": false,
    "lang": "en",
    "lighter": null,
    "heavier": null,
    "earlier": {
      "relative_path": "posts/2017-08-11-mastering-console-log.md",
      "content": "<p>Using <code>console.log()</code> to debug JavaScript, a dynamic weakly-typed interpreted language, feels like drinking beers on a lazy summer sunday afternoon.</p>\n<p>It is easy and you do it without thinking too much on how you could probably be more productive doing something else.</p>\n<p>Truth is that in all the other days of the week you don't avoid spraying your code with the <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger\"><code>debugger</code></a> keyword and let the developer tools stop and show you the execution context at that exact location.</p>\n<pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\">function yourCodeThatCouldBeWorking() {\n  const x = 1337;\n  const y = parseInt(window.prompt(&#39;Y value:&#39;));\n  debugger; // &lt;- hello\n  return (x / y);\n}\n\n</span></code></pre>\n<p>But lazy summer sunday afternoons are on to get us, and <code>console.log()</code> is our friend for the mood.</p>\n<h2 id=\"console-log-basic-mode\">console.log() basic mode</h2>\n<p>The most basic usage of <code>console.log</code> is to just pass it a string. You can step this up a bit by following the string with JS objects and/or strings. Like this:</p>\n<pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\">const v1 = { x: 123, y: 321 };\nconsole.log(&quot;Vector v1: (&quot;, v1.x, &quot;,&quot;, v1.y, &quot;)&quot;);\n// or just:\nconsole.log(&quot;Vector v1:&quot;, v1);\n</span></code></pre>\n<p>Try it in your developer tools console (Ctrl Shift i, or in mac Cmd Shift i).</p>\n<p>This is a particularly simple and helpful way to properly debug JavaScript. Specially if your code is creating code or functions in runtime, making it hard to setup breakpoints in the debugger window.</p>\n<p>But who needs breakpoints when we have <code>console.log</code> ? :)</p>\n<h2 id=\"colorful-console-log-composer-mode\">Colorful console.log() composer mode</h2>\n<p>Besides its simplicity, my next favourite thing in <code>console.log</code> is that it also allows you to pass a format string to be replaced with what you want:</p>\n<pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\">const v1 = { x: 123, y: 321 };\nconsole.log(&quot;v1 (%i, %i)&quot;, v1.x, v1.y);\n</span></code></pre>\n<p>There are a handful of other <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/console#Using_string_substitutions\">string substitutions</a> you can use.</p>\n<p>While apparently this is not a big improvement over the simplest mode, it can be used to do a few things that would not be so easy otherwise.</p>\n<p><strong>Colors in console.log</strong></p>\n<p>You can style your output with CSS through the %c substitution:</p>\n<pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\">const v1 = { x: 123, y: 321 };\nconsole.log( &quot;%c[Vector 1] %c(%i, %i)%c\\nin object %o&quot;\n           , &quot;background: #242; color: #bada55&quot;\n           , &quot;background: #424; color: #c0ffee&quot;\n           , v1.x, v1.y\n           , &quot;&quot; //&lt;- clears style\n           , v1\n           );\n</span></code></pre>\n<p><strong>Dynamically create your output</strong></p>\n<p>You can also compose the log format string with code and pass it the args as needed.\nSuppose you are logging messages that can have a varying number of attributes:</p>\n<pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\">const someMsg =\n  { type: &quot;WORKER_ERROR&quot;\n  , action: &quot;division&quot;\n  , args: [123, 0]\n  };\n\nfunction logMessage(msg) {\n  let logFmt = &quot;%c[%s]%c - %c%s%c&quot;;\n  let logArgs =\n    [ &quot;background: #242; color: #bada55&quot;\n    , msg.type\n    , &quot;&quot;\n    , &quot;background: #424; color: #c0ffee&quot;\n    , msg.action\n    , &quot;&quot;\n    ];\n  if (msg.action === &quot;division&quot;) {\n    logFmt += &quot;: %i / %i&quot;;\n    logArgs.push(msg.args[0]);\n    logArgs.push(msg.args[1]);\n  } else {\n    logFmt += &quot; with args %o&quot;;\n    logArgs.push(msg.args);\n  }\n  // finally print it:\n  console.log(logFmt, ...logArgs);\n}\n\nlogMessage(someMsg);\n</span></code></pre><h2 id=\"measuring-console-log\">Measuring console.log()</h2>\n<p>Another thing to keep in mind when using <code>console.log</code> is that it is not free. It does come with a performance hit, how much exactly ? Lets measure it like we did for <a href=\"https://hugodaniel.com/posts/how-fast-is-nothing/\">requestAnimationFrame()</a>:</p>\n<p>For this test I am going to print just 32 simple console.log messages. I know that this is not a lot, it actually is nothing when compared to using console.log on mousemove events or any other fast firing event, but it should be enough to test.</p>\n<pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\">performance.mark(&quot;Before&quot;);\n// print 32 lines\nfor(let i = 0; i &lt; 32; i++)\n  console.log(&quot;One of the simplest console.log() possible&quot;, i);\nperformance.mark(&quot;After&quot;);\nperformance.measure(&quot;console.log&quot;, &quot;Before&quot;, &quot;After&quot;);\nconst totalTime = performance.getEntriesByType(&quot;measure&quot;)[0].duration;\nconsole.log(&quot;console.log() in %ims&quot;, totalTime);\nperformance.clearMarks();\nperformance.clearMeasures();\n</span></code></pre>\n<p>In my Firefox Developer Edition (56.0b1) console it prints</p>\n<pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\">&quot;console.log() in 15ms&quot;\n</span></code></pre>\n<p>15 milliseconds is <em>a lot</em> of time in a computer perspective, specially since we are just printing 32 messages, it is about 0.45ms per message.</p>\n<p>To keep it in perspective here is the time it takes to parse a huge 128KB JSON string:</p>\n<pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\">function jsonParseAndMeasure(jsonStr) {\n  performance.mark(&quot;jsonStart&quot;);\n  const json = JSON.parse(jsonStr);\n  performance.mark(&quot;jsonEnd&quot;);\n  performance.measure(&quot;JSON.parse&quot;, &quot;jsonStart&quot;, &quot;jsonEnd&quot;);\n  const totalTime = performance.getEntriesByType(&quot;measure&quot;)[0].duration;\n  console.log(&quot;JSON.parse in %ims&quot;, totalTime);\n  performance.clearMarks();\n  performance.clearMeasures();\n}\n\njsonParseAndMeasure(&quot;HUGE JSON STRING HERE&quot;);\n</span></code></pre>\n<p>For a 128KB JSON string it prints:</p>\n<pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\">&quot;JSON.parse in 0ms&quot;\n</span></code></pre>\n<p>Hmm... maybe that is not enough, lets increase it to a 2MB JSON string:</p>\n<pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\">&quot;JSON.parse in 0ms&quot;\n</span></code></pre>\n<p>Ok... what about a 50MB JSON string ?</p>\n<pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\">&quot;JSON.parse in 17ms&quot;\n</span></code></pre>\n<p>Thats more like it. About the same time it took console.log to print 32 simple messages. There are a few attenuating factors for this in production, but it is good to keep this in mind when leaving those debugging messages in your production code ;)</p>\n<h2 id=\"buffering-console-log\">Buffering console.log()</h2>\n<p>There is an alternative if you have your reasons to use <code>console.log</code> in production code: buffering.</p>\n<p>Instead of printing each message as it comes, lets place them in an array and dump it in a single <code>console.log</code> call every second or so.</p>\n<pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\">let buffer = [];\n// use a log function instead of directly calling console.log:\nfunction log(str, args) {\n  buffer.push({ str, args });\n}\n\nfunction printBuffer() {\n  // start by copying the buffer and clearing it\n  const buf = buffer.slice(0);\n  buffer = [];\n  // dump the buffer in a single console.log call\n  if (buf.length &gt; 0) {\n    let logStr = &quot;&quot;;\n    let logArgs = [];\n    buf.map(msg =&gt; {\n      logStr += &quot;%s, %o\\n&quot;;\n      logArgs.push(msg.str);\n      logArgs.push(msg.args);\n    });\n    console.log(logStr, ...logArgs);\n  }\n  setTimeout(printBuffer, 1000); // run every 1000ms\n}\n\nprintBuffer(); // &lt;- start it\n</span></code></pre>\n<p>That should save you some performance complaints. I hope it helps :)</p>\n",
      "permalink": "https://hugodaniel.com/posts/mastering-console-log/",
      "slug": "mastering-console-log",
      "ancestors": [
        "_index.md",
        "posts/_index.md"
      ],
      "title": "Mastering console.log()",
      "description": "Working with the developer tools most used console function",
      "updated": null,
      "date": "2017-08-11",
      "year": 2017,
      "month": 8,
      "day": 11,
      "taxonomies": {},
      "extra": {
        "place": "Lisboa",
        "author": "Hugo Daniel"
      },
      "path": "/posts/mastering-console-log/",
      "components": [
        "posts",
        "mastering-console-log"
      ],
      "summary": null,
      "toc": [
        {
          "level": 2,
          "id": "console-log-basic-mode",
          "permalink": "https://hugodaniel.com/posts/mastering-console-log/#console-log-basic-mode",
          "title": "console.log() basic mode",
          "children": []
        },
        {
          "level": 2,
          "id": "colorful-console-log-composer-mode",
          "permalink": "https://hugodaniel.com/posts/mastering-console-log/#colorful-console-log-composer-mode",
          "title": "Colorful console.log() composer mode",
          "children": []
        },
        {
          "level": 2,
          "id": "measuring-console-log",
          "permalink": "https://hugodaniel.com/posts/mastering-console-log/#measuring-console-log",
          "title": "Measuring console.log()",
          "children": []
        },
        {
          "level": 2,
          "id": "buffering-console-log",
          "permalink": "https://hugodaniel.com/posts/mastering-console-log/#buffering-console-log",
          "title": "Buffering console.log()",
          "children": []
        }
      ],
      "word_count": 889,
      "reading_time": 5,
      "assets": [],
      "draft": false,
      "lang": "en",
      "lighter": null,
      "heavier": null,
      "earlier": null,
      "later": null,
      "translations": []
    },
    "later": {
      "relative_path": "posts/2017-10-03-in-loving-memory-of-immutable.md",
      "content": "<p>Any JavaScript spaghetti worth its salt won't keep track of its objects references or their updates.\nThese are things that happen between the mind of a chef and the ether of a planned portion with lots of defensive copying.\n<a href=\"https://facebook.github.io/immutable-js/\">Immutable.js</a> aims to reduce these portion sizes to match the ones in fancy restaurants while avoiding ingredients like:</p>\n<pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\">JSON.parse(JSON.stringify(obj))\n\n</span></code></pre>\n<p>To try out this new pepper lets open the developer tools in a new tab and sharpen our sour-sweet tooth.</p>\n<p><img src=\"/images/devtools.png\" alt=\"Screenshot of the Firefox developer tools in console mode.\" /></p>\n<h2 id=\"how-many-calories-has-the-appetizer\">How many calories has the appetizer ?</h2>\n<p>In order to measure the amount of memory that Immutable.js uses by itself lets marinate it in a quick and dirty formula:</p>\n<ol>\n<li>Open the devtools</li>\n<li>Define a simple array with a single item in it and print it to the console\n<ul>\n<li><pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\"> let test1 = [1337];\n</span><span style=\"color:#c0c5ce;\"> console.log(test1);\n</span></code></pre></li>\n</ul>\n<pre style=\"background-color:#2b303b;\">\n<code></code></pre></li>\n<li>Measure the memory usage (memory tab of the dev tools)</li>\n<li>Load Immutable.js directly into the console (copy pasting its minified source directly into the console)</li>\n<li>Define a simple list with a single item in it and print it to the console\n<ul>\n<li><pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\"> let test2 = Immutable.List.of(1337);\n</span><span style=\"color:#c0c5ce;\"> console.log(test2);\n</span></code></pre></li>\n</ul>\n<pre style=\"background-color:#2b303b;\">\n<code></code></pre></li>\n<li>Measure the memory usage again</li>\n</ol>\n<p>The key points are 3. and 6. so lets do it and take a look into the memory info. For these measures I am using Firefox Developer Edition 53.0a2 (2017-03-05) (64-bit) in OSX Sierra.</p>\n<p>After point 3. I have 2.11MB of used memory with the following layout:</p>\n<ul>\n<li><em>scripts</em>: 37KiB (347 objects)</li>\n<li><em>strings</em>: 362KiB (9685 objects)</li>\n<li><em>objects</em>: 813KiB (11325 objects)</li>\n<li><em>other</em>: 849KiB (18365 objects)</li>\n</ul>\n<p>This is for nothing but an empty tab with devtools opened after point 3. in the magic formula.</p>\n<p>Now lets load <a href=\"https://raw.githubusercontent.com/facebook/immutable-js/master/dist/immutable.min.js\">Immutable.js raw minification</a> and run the rest of the steps.</p>\n<p>After point 6.  I have 2.53MB of used memory with the following layout:</p>\n<ul>\n<li><em>scripts</em>: 248KiB (1717 objects)</li>\n<li><em>strings</em>: 384KiB (10252 objects)</li>\n<li><em>objects</em>: 904KiB (12618 objects)</li>\n<li><em>other</em>: 933KiB (19984 objects)</li>\n</ul>\n<p><strong>Immutable.js makes the memory usage go up from 2.1MB to about 2.5MB.</strong> That's around 0.4MB just to load the minified Immutable.js in memory.</p>\n<p>Lets keep this value as a reference in further tests. I am keeping these memory snapshots also for further reference.</p>\n<p>How can we leverage the juice from these 0.4MB into our secret sauce ?</p>\n<h2 id=\"a-list-of-many-secrets\">A list of many secrets</h2>\n<p>Immutable allows the discerning chef to cook with well defined ingredients. You can define your own data types and use them as immutable everywhere you want to. To do that the Immutable.Record is their provided interface. </p>\n<p>The following code uses it to define a data type for a 2D point, with X and Y coordinates, and then create some points with it.</p>\n<pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\">const Pt = Immutable.Record( { x: 0, y: 0} );\n\nconst pt1 = new Pt(); // uses x: 0, y: 0 by default\nconst pt2 = new Pt({ y: 123 }); // uses x: 0 by default\nconst pt3 = new Pt({ x: 123, y: 321 }); // uses your provided values\n</span></code></pre>\n<p>Fast-food junkies could do the same in straight JS with the simpler approach:</p>\n<pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\">function PtJS(x = 0, y = 0) {\n\tthis.x = x;\n\tthis.y = y;\n}\n\nlet jspt1 = new PtJS();\nlet jspt2 = new PtJS(0, 123);\nlet jspt3 = new PtJS(123, 321);\n</span></code></pre>\n<p>Some might even argue that they are not wasting the memory that Immutable is. Master chefs are always looking for opportunities to learn, to study and to teach. </p>\n<p>Now for a simple test, create a list with 10000 of those 2D points and compare memory readings of the Immutable approach with the plain JS approach.</p>\n<p>First the plain JS approach (lets assume the constructor is already created as above).</p>\n<pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\">\nlet testArray = [];\nfor(let i = 0; i &lt; 10000; i++) {\n  testArray.push(new PtJS());\n}\n\n</span></code></pre>\n<p>After measuring this in the Memory tab we get 2.92MB in this layout:</p>\n<ul>\n<li><em>scripts</em>: 228KiB (1692 objects)</li>\n<li><em>strings</em>: 384KiB (10251 objects)</li>\n<li><em>objects</em>: 1MiB (22688 objects)</li>\n<li><em>other</em>: 888KiB (19990 objects)</li>\n</ul>\n<p>That seems fair, we get an increase of about 390KiB in comparison to our previous measurement. That should be enough motivation to roll our Chefs Knives suitecase of Persistency and do it in Immutable style to measure it on top of this 2.92MB already in use.</p>\n<pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\">const defaultPt = new Pt();\nconst testLst = Immutable.Repeat(defaultPt, 10000);\n</span></code></pre>\n<p>After measuring this in the Memory tab we get 2.91MB. This is a decrease of about 10KiB from our previous memory usage. How is this possible ? Is the data even there ?</p>\n<pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\">testLst.first().x;\n// returns 0\ntestLst.size();\n// returns 10000\n</span></code></pre>\n<p>Yep, it's all there. Immutable.js allows you to take good care of your memory, but as with all sharp knifes you need to know how to avoid hurting yourself. Lets dive a bit further to understand what is going on and how to master these data structures.</p>\n<h2 id=\"master-chef-mystery-boxes\">Master Chef Mystery Boxes</h2>\n<p>One common misconception about immutable data structures is that there is a lot of useless copying being done. In fact this is so common that there are even <a href=\"https://github.com/rtfeldman/seamless-immutable\">JS libraries based on it</a>. Playing with the flavour of common things note the most typical data structure in functional languages.</p>\n<h3 id=\"the-single-linked-list\">The single linked list.</h3>\n<p><img src=\"/images/immutable-list1.gif\" alt=\"A single linked list with 3 values\" /></p>\n<p>Supposed that this is a immutable list. It is not possible to add, remove or change its values without returning a new version of it.</p>\n<p>Does this mean that we need to copy all of it when we need to put a new value in it ? Not necessarily. We can just create the new list item and make sure its pointer is targeting the beginning of the original list.</p>\n<p><img src=\"/images/immutable-list2.png\" alt=\"Placing a new value in the previous list\" /></p>\n<p>This works because the list is immutable, we know for sure that the original list won't change so <strong>it is possible to reuse its values</strong>, no copying is involved in this.</p>\n<p>As before, our new immutable list is again defined by its first value, which in this new case is our new value.</p>\n<h3 id=\"master-the-simple-cuts-first\">Master the simple cuts first</h3>\n<p>Many operations are possible on our immutable single linked list that leverage the fact that it is an immutable list.</p>\n<p>Operations like <em>head</em> (return the first value in the list) and <em>tail</em> (return all the items in the list except for the first) are almost instantaneous to implement. For <em>head</em> we just return the value of the first item and for <em>tail</em> we just return the first item pointer value (which is an immutable single linked list, in this case, our original 3 value list).</p>\n<h4 id=\"concat\">Concat</h4>\n<p>Joining two lists is one of those simple operations that is worth your time and attention in order to understand it. If we have 2 different immutable lists that we want to join we need to go to the first list and adjust the last pointer of the last item to point to the first item of the second list.</p>\n<p>Here it is in pictures:</p>\n<p><img src=\"/images/immutable_two_lists.png\" alt=\"Joining these two lists\" /></p>\n<p><img src=\"/images/immutable_two_lists_2.png\" alt=\"We need to make the last item point to the first item of the second list\" /></p>\n<p><img src=\"/images/immutable_two_lists_3.png\" alt=\"A copy of this element is necessary because we can't just change it to point to the first item of lst2\" /></p>\n<p><img src=\"/images/immutable_two_lists_4.png\" alt=\"But now we need to make the previous item point to the newly created copy. So a copy of it will also be necessary.\" /></p>\n<p><img src=\"/images/immutable_two_lists_final.png\" alt=\"That is why to concat two lists a new list is made with a copy of the elements in the first list\" /></p>\n<p>Concat is a heavy operation, it mostly depends on the size of the first list. There are a few tricks to make it faster.</p>\n<p>To keep it simple I am not going to go much more into this and move to the point.</p>\n<h2 id=\"the-best-recipe-is-made-of-many-subrecipes\">The best recipe is made of many subrecipes</h2>\n<p>The list holds data. That's why it's called a <em>data</em> structure. Now what if instead of directly putting our data in each list item we could instead just point to the data ? Like this:</p>\n<p><img src=\"/images/immutable_lazy1.png\" alt=\"List doesn't directly hold the data anymore\" /></p>\n<p>The list effectively now holds <strong>a way to reach</strong> each value instead of the real values. We can get more generic and greatly simplify it by saying that in each list item there is a recipe to reach each value. In the above picture this <em>recipe</em> generalization is represented by the red arrows.</p>\n<p>Let me try to simplify it with the hope that it might stand out the intended purpose.</p>\n<p><img src=\"/images/immutable_lazy2.png\" alt=\"A list of recipes can be a list of values\" /></p>\n<p>The term <em>recipe</em> is not chosen by chance: it represents something that must be done to produce the value that the list item holds.</p>\n<p>If we follow the <em>recipe</em> in each item we can get to the intended values. For instance, suppose that this is a list of JS Number's, a good recipe to produce the value would be to just call Number() on the data. If it was a list of String's, a good recipe would be to call String() on the data. This also holds for very complex values, say this is a list of balanced tree's, or your favourite custom complex data type, <strong>a recipe is the way to construct the value</strong>, could just be following a pointer but perhaps that would not be a very useful constructor due to being too general.</p>\n<h3 id=\"lazy-concat\">Lazy concat</h3>\n<p>In our previous look into <em>concat</em> we noticed that it was a heavy operation, requiring a full copy of the first list that we want to join. When working with immutable data there are only a few of these &quot;heavy&quot; operations that do need a full copy.</p>\n<p>Now that we are taking quality steps as chefs how about we use a <em>recipe</em> for concat ?</p>\n<p>Instead of doing a full copy of the first list, just copy the first element and make it point to a recipe. That way, no matter the size of the lists, concat would be done in a single operation (the first item). Here it is in a picture:</p>\n<p><img src=\"/images/immutable_concat_lazy.png\" alt=\"Why copy the whole first list if we don't know if it will be needed ?\" /></p>\n<p>Now if we need the second element of the list the recipe will be followed to get it.</p>\n<p>That is a simple recipe:\ncopy the first list up to the needed value, if the copying is done but the intended value is not yet reached then start going through the second list values (without copying them). In the case we want the 2nd value of a concat'ed list a single copy will happen because we already copied the first item when concat was called. This is a case where the recipe is itself the whole concat operation, meaning that it will only copy until the end of the first list and after it will use the reference of the second list.</p>\n<p>This <a href=\"https://en.wikipedia.org/wiki/Thunk\"><em>recipe</em></a> approach is usually known as laziness and typically enhanced with a cache of results to avoid copying and constructing the same values over again (this caching approach is known as &quot;memoization&quot;).</p>\n<h2 id=\"cuisine-du-monde\">Cuisine du monde</h2>\n<p>Immutable.js makes good use of these techniques to avoid doing work when necessary and unnecessary copies. Their approach is lean and well thought, clearly separating the values from the way they are traversed.</p>\n<p>Lets look at our Immutable approach again:</p>\n<pre style=\"background-color:#2b303b;\">\n<code><span style=\"color:#c0c5ce;\">const defaultPt = new Pt();\nconst testLst = Immutable.Repeat(defaultPt, 10000);\ntestLst.first().x;\n</span></code></pre>\n<p>A few things stand out:</p>\n<ol>\n<li>We are always using the same reference <em>defaultPt</em> instead of creating a new value in each item.\n<ul>\n<li>This is possible thanks to immutability, if we change it we are effectively creating a new value and a new list.</li>\n<li>Immutability encourages reutilization and is typically a GC friendly approach.</li>\n</ul>\n</li>\n<li>Repeat just returns a <em>recipe</em> (thunk)\n<ul>\n<li>No heavy work is actually done, it just returns a way to access and construct the values</li>\n<li>We used 10000 but could have used infinite with no performance or memory hit</li>\n<li>Work is only done when values are being requested and only up until them.</li>\n</ul>\n</li>\n</ol>\n<p>Immutable.js also uses a few other tricks to speed up common operations. For instance their List approach uses deques, which means that it keeps your list split in two, so [1,2,3,4,5,6] is kept by Immutable as [1,2,3] and [6,5,4] (reversed rest). This is a very simplified explanation of it, but in practice it allows for very fast insertions in the beginning and end of the list (<a href=\"http://blog.klipse.tech/javascript/2016/06/23/immutable-perf.html\">faster than JS arrays</a>).</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>Immutable is certainly a different way of doing JS. Given the normal tendency JS coders have to lean more towards object oriented concepts, immutable feels like the schrodinger's immigrant in a foreign land.</p>\n<p><img src=\"/images/immigrant.jpeg\" alt=\"\" /></p>\n<p>I hope this post was in any way useful to you. Immutable sure is a fun library to get to know and work with. </p>\n",
      "permalink": "https://hugodaniel.com/posts/in-loving-memory-of-immutable/",
      "slug": "in-loving-memory-of-immutable",
      "ancestors": [
        "_index.md",
        "posts/_index.md"
      ],
      "title": "In loving memory of Immutable.js",
      "description": "Using Immutable.js and trying to make some sense out of its memory usage.",
      "updated": null,
      "date": "2017-10-03",
      "year": 2017,
      "month": 10,
      "day": 3,
      "taxonomies": {},
      "extra": {
        "place": "Lisboa",
        "author": "Hugo Daniel"
      },
      "path": "/posts/in-loving-memory-of-immutable/",
      "components": [
        "posts",
        "in-loving-memory-of-immutable"
      ],
      "summary": null,
      "toc": [
        {
          "level": 2,
          "id": "how-many-calories-has-the-appetizer",
          "permalink": "https://hugodaniel.com/posts/in-loving-memory-of-immutable/#how-many-calories-has-the-appetizer",
          "title": "How many calories has the appetizer ?",
          "children": []
        },
        {
          "level": 2,
          "id": "a-list-of-many-secrets",
          "permalink": "https://hugodaniel.com/posts/in-loving-memory-of-immutable/#a-list-of-many-secrets",
          "title": "A list of many secrets",
          "children": []
        },
        {
          "level": 2,
          "id": "master-chef-mystery-boxes",
          "permalink": "https://hugodaniel.com/posts/in-loving-memory-of-immutable/#master-chef-mystery-boxes",
          "title": "Master Chef Mystery Boxes",
          "children": [
            {
              "level": 3,
              "id": "the-single-linked-list",
              "permalink": "https://hugodaniel.com/posts/in-loving-memory-of-immutable/#the-single-linked-list",
              "title": "The single linked list.",
              "children": []
            },
            {
              "level": 3,
              "id": "master-the-simple-cuts-first",
              "permalink": "https://hugodaniel.com/posts/in-loving-memory-of-immutable/#master-the-simple-cuts-first",
              "title": "Master the simple cuts first",
              "children": [
                {
                  "level": 4,
                  "id": "concat",
                  "permalink": "https://hugodaniel.com/posts/in-loving-memory-of-immutable/#concat",
                  "title": "Concat",
                  "children": []
                }
              ]
            }
          ]
        },
        {
          "level": 2,
          "id": "the-best-recipe-is-made-of-many-subrecipes",
          "permalink": "https://hugodaniel.com/posts/in-loving-memory-of-immutable/#the-best-recipe-is-made-of-many-subrecipes",
          "title": "The best recipe is made of many subrecipes",
          "children": [
            {
              "level": 3,
              "id": "lazy-concat",
              "permalink": "https://hugodaniel.com/posts/in-loving-memory-of-immutable/#lazy-concat",
              "title": "Lazy concat",
              "children": []
            }
          ]
        },
        {
          "level": 2,
          "id": "cuisine-du-monde",
          "permalink": "https://hugodaniel.com/posts/in-loving-memory-of-immutable/#cuisine-du-monde",
          "title": "Cuisine du monde",
          "children": []
        },
        {
          "level": 2,
          "id": "conclusion",
          "permalink": "https://hugodaniel.com/posts/in-loving-memory-of-immutable/#conclusion",
          "title": "Conclusion",
          "children": []
        }
      ],
      "word_count": 2158,
      "reading_time": 11,
      "assets": [],
      "draft": false,
      "lang": "en",
      "lighter": null,
      "heavier": null,
      "earlier": null,
      "later": null,
      "translations": []
    },
    "translations": []
  }
});
		</script>
	</body>
</html>
